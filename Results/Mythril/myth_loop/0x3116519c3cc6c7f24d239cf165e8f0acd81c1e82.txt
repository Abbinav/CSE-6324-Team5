==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Getters
Function name: expiringCouponsAtIndex(uint256,uint256)
PC address: 2821
Estimated Gas Usage: 1490 - 1775
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2361

_state.epochs[epoch].coupons.expiring[i]

--------------------
Initial State:

Account: [CREATOR], balance: 0x401c0080400000002, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: expiringCouponsAtIndex(uint256,uint256), txdata: 0x4c73609900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Comptroller
Function name: expiringCouponsAtIndex(uint256,uint256)
PC address: 3021
Estimated Gas Usage: 1512 - 1797
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2361

_state.epochs[epoch].coupons.expiring[i]

--------------------
Initial State:

Account: [CREATOR], balance: 0x40081000400000001, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: expiringCouponsAtIndex(uint256,uint256), txdata: 0x4c73609900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Bonding
Function name: expiringCouponsAtIndex(uint256,uint256)
PC address: 4018
Estimated Gas Usage: 1534 - 1819
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2361

_state.epochs[epoch].coupons.expiring[i]

--------------------
Initial State:

Account: [CREATOR], balance: 0x401, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: expiringCouponsAtIndex(uint256,uint256), txdata: 0x4c73609900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Market
Function name: expiringCouponsAtIndex(uint256,uint256)
PC address: 4127
Estimated Gas Usage: 1512 - 1797
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2361

_state.epochs[epoch].coupons.expiring[i]

--------------------
Initial State:

Account: [CREATOR], balance: 0x1000000, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: expiringCouponsAtIndex(uint256,uint256), txdata: 0x4c73609900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Getters
Function name: epochTime()
PC address: 4980
Estimated Gas Usage: 1223 - 3772
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:67

require(c >= a, "SafeMath: addition overflow")

--------------------
Initial State:

Account: [CREATOR], balance: 0x800000000000000, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Comptroller
Function name: epochTime()
PC address: 5191
Estimated Gas Usage: 1245 - 3794
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:67

require(c >= a, "SafeMath: addition overflow")

--------------------
Initial State:

Account: [CREATOR], balance: 0x800000000000000, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Getters
Function name: epochTime()
PC address: 5246
Estimated Gas Usage: 823 - 2994
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:127

require(b <= a, errorMessage)

--------------------
Initial State:

Account: [CREATOR], balance: 0x8008, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Market
Function name: couponRedemptionPenalty(uint256,uint256)
PC address: 5387
Estimated Gas Usage: 1884 - 3018
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:4199

if(timeIntoEpoch > couponEpochDecay) {

            return 0;

        }

--------------------
Initial State:

Account: [CREATOR], balance: 0x10, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: couponRedemptionPenalty(uint256,uint256), txdata: 0xa1eb31e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Comptroller
Function name: epochTime()
PC address: 5457
Estimated Gas Usage: 845 - 3016
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:127

require(b <= a, errorMessage)

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000020000, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Implementation
Function name: expiringCouponsAtIndex(uint256,uint256)
PC address: 6459
Estimated Gas Usage: 1512 - 1797
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2361

_state.epochs[epoch].coupons.expiring[i]

--------------------
Initial State:

Account: [CREATOR], balance: 0x461, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: expiringCouponsAtIndex(uint256,uint256), txdata: 0x4c73609900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: deposit(uint256)
PC address: 7766
Estimated Gas Usage: 20814 - 97383
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2667

_state.accounts[account].staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000082, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x1000000000000000, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [ATTACKER], function: deposit(uint256), txdata: 0xb6b55f25882044020a0408030d670e40040007cf300000204130a4288004550662740086, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: deposit(uint256)
PC address: 7852
Estimated Gas Usage: 20814 - 97383
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2667

_state.accounts[account].staged = _state.accounts[account].staged.add(amount)

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000082, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x1000000000000000, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [ATTACKER], function: deposit(uint256), txdata: 0xb6b55f25882044020a0408030d670e40040007cf300000204130a4288004550662740086, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: deposit(uint256)
PC address: 7866
Estimated Gas Usage: 20814 - 97383
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2669

_state.balance.staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x44000800000000002, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: bond(uint256), txdata: 0x9940686e0000000000000000000000000000000000000000000000000000000000000000, value: 0x0
Caller: [CREATOR], function: deposit(uint256), txdata: 0xb6b55f252aa72f45ff8974400e08a0a234a414850020180ca20a8003000c015821c03834, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: deposit(uint256)
PC address: 7891
Estimated Gas Usage: 20814 - 97383
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2669

_state.balance.staged = _state.balance.staged.add(amount)

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000082, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x1000000000000000, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [ATTACKER], function: deposit(uint256), txdata: 0xb6b55f25882044020a0408030d670e40040007cf300000204130a4288004550662740086, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Bonding
Function name: epochTime()
PC address: 8270
Estimated Gas Usage: 1267 - 3816
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:67

require(c >= a, "SafeMath: addition overflow")

--------------------
Initial State:

Account: [CREATOR], balance: 0x200000000000000, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Implementation
Function name: couponRedemptionPenalty(uint256,uint256)
PC address: 8410
Estimated Gas Usage: 1907 - 3041
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:4199

if(timeIntoEpoch > couponEpochDecay) {

            return 0;

        }

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000001, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: couponRedemptionPenalty(uint256,uint256), txdata: 0xa1eb31e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: withdraw(uint256)
PC address: 8414
Estimated Gas Usage: 20795 - 99856
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2677

_state.accounts[account].staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x100000000000020, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: withdraw(uint256)
PC address: 8501
Estimated Gas Usage: 20795 - 99856
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2677

_state.accounts[account].staged = _state.accounts[account].staged.sub(amount, reason)

--------------------
Initial State:

Account: [CREATOR], balance: 0x100000000000020, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: withdraw(uint256)
PC address: 8516
Estimated Gas Usage: 20795 - 99856
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2679

_state.balance.staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x4, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: bond(uint256), txdata: 0x9940686e0000000000000000000000000000000000000000000000000000000000000000, value: 0x0
Caller: [ATTACKER], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Bonding
Function name: withdraw(uint256)
PC address: 8542
Estimated Gas Usage: 20795 - 99856
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2679

_state.balance.staged = _state.balance.staged.sub(amount, reason)

--------------------
Initial State:

Account: [CREATOR], balance: 0x100000000000020, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Market
Function name: epochTime()
PC address: 9138
Estimated Gas Usage: 1245 - 3794
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:67

require(c >= a, "SafeMath: addition overflow")

--------------------
Initial State:

Account: [CREATOR], balance: 0x1, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [ATTACKER], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Bonding
Function name: epochTime()
PC address: 9564
Estimated Gas Usage: 867 - 3038
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:127

require(b <= a, errorMessage)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Market
Function name: epochTime()
PC address: 10326
Estimated Gas Usage: 845 - 3016
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:127

require(b <= a, errorMessage)

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Implementation
Function name: advance()
PC address: 13490
Estimated Gas Usage: 13175 - 86330
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2971

if (!must) {

            revert(

                string(

                    abi.encodePacked(

                        stringifyTruncated(file),

                        COLON,

                        stringifyTruncated(reason)

                    )

                )

            );

        }

--------------------
Initial State:

Account: [CREATOR], balance: 0x1, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: advance(), txdata: 0xea105ac7, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: deposit(uint256)
PC address: 14247
Estimated Gas Usage: 20858 - 97427
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2667

_state.accounts[account].staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x2000008, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: deposit(uint256), txdata: 0xb6b55f2588403ad10800200d8a50a2ccd805224c3105c682e318433e406a68836316cb5d, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: deposit(uint256)
PC address: 14333
Estimated Gas Usage: 20858 - 97427
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2667

_state.accounts[account].staged = _state.accounts[account].staged.add(amount)

--------------------
Initial State:

Account: [CREATOR], balance: 0x2000008, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: deposit(uint256), txdata: 0xb6b55f2588403ad10800200d8a50a2ccd805224c3105c682e318433e406a68836316cb5d, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: deposit(uint256)
PC address: 14347
Estimated Gas Usage: 20858 - 97427
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2669

_state.balance.staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x1000001000a1001, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: transferCoupons(address,address,uint256,uint256), txdata: 0x005edd370000000000000000000000000002000801024040040000800001802020040108000000000000000000000000804001800480408020404080404001208040802040200010084004000000021008002000080020080180801000400040040020040000000000000000000000000000000000000000000000000000000000000000, value: 0x0
Caller: [SOMEGUY], function: deposit(uint256), txdata: 0xb6b55f251a95d80000401c500a045620021014df04292a204cc2700a4c4040050b8a5440, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: deposit(uint256)
PC address: 14372
Estimated Gas Usage: 20858 - 97427
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2669

_state.balance.staged = _state.balance.staged.add(amount)

--------------------
Initial State:

Account: [CREATOR], balance: 0x2000008, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: deposit(uint256), txdata: 0xb6b55f2588403ad10800200d8a50a2ccd805224c3105c682e318433e406a68836316cb5d, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Implementation
Function name: epochTime()
PC address: 14751
Estimated Gas Usage: 1245 - 3794
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:67

require(c >= a, "SafeMath: addition overflow")

--------------------
Initial State:

Account: [CREATOR], balance: 0x0, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [CREATOR], function: epochTime(), txdata: 0x5053e461, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: withdraw(uint256)
PC address: 14895
Estimated Gas Usage: 20729 - 99790
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2677

_state.accounts[account].staged

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000020, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: withdraw(uint256)
PC address: 14982
Estimated Gas Usage: 20729 - 99790
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2677

_state.accounts[account].staged = _state.accounts[account].staged.sub(amount, reason)

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000020, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: withdraw(uint256)
PC address: 14997
Estimated Gas Usage: 20729 - 99790
Read of persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2679

_state.balance.staged

--------------------
Initial State:

Account: [CREATOR], balance: 0xa4910108800032, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x1, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: transferCoupons(address,address,uint256,uint256), txdata: 0x005edd370000000000000000000000000440100280400020010001000020200104000200000000000000000000000000800104200840108080044080404080021008404000400102000400000008000000001004102020084020000800100200040080000000000000000000000000000000000000000000000000000000000000000000, value: 0x0
Caller: [ATTACKER], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== State access after external call ====
SWC ID: 107
Severity: Low
Contract: Implementation
Function name: withdraw(uint256)
PC address: 15023
Estimated Gas Usage: 20729 - 99790
Write to persistent state following external call
The contract account state is accessed after an external call to a fixed address. To prevent reentrancy issues, consider accessing the state only before the call, especially if the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract in an intermediate state.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:2679

_state.balance.staged = _state.balance.staged.sub(amount, reason)

--------------------
Initial State:

Account: [CREATOR], balance: 0x40000000000020, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: withdraw(uint256), txdata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000, value: 0x0

==== Dependence on predictable environment variable ====
SWC ID: 116
Severity: Low
Contract: Implementation
Function name: epochTime()
PC address: 19240
Estimated Gas Usage: 845 - 3016
A control flow decision is made based on The block.timestamp environment variable.
The block.timestamp environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.
--------------------
In file: ./contracts/m_loop/loop5/0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol:127

require(b <= a, errorMessage)

--------------------
Initial State:

Account: [CREATOR], balance: 0x2141040040091090, nonce:0, storage:{}
Account: [ATTACKER], balance: 0x0, nonce:0, storage:{}
Account: [SOMEGUY], balance: 0x0, nonce:0, storage:{}

Transaction Sequence:

Caller: [CREATOR], calldata: , value: 0x0
Caller: [SOMEGUY], function: epochTime(), txdata: 0x5053e461, value: 0x0



---------------------------------------------
For contract 0x3116519c3cc6c7f24d239cf165e8f0acd81c1e82.sol
Tool Runtime = 16791.62730932799 seconds
#############################################