digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_dividends = dividendsOf(msg.sender)

IRs:
TMP_5(uint256) = INTERNAL_CALL, bestyearn.dividendsOf(address)(msg.sender)
_dividends(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_dividends >= 0)

IRs:
TMP_6(bool) = _dividends >= 0
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
info.users[msg.sender].scaledPayout += int256(_dividends * FLOAT_SCALAR)

IRs:
REF_5(mapping(address => bestyearn.User)) -> info.users
REF_6(bestyearn.User) -> REF_5[msg.sender]
REF_7(int256) -> REF_6.scaledPayout
TMP_8(uint256) = _dividends (c)* FLOAT_SCALAR
TMP_9 = CONVERT TMP_8 to int256
REF_7(-> info) = REF_7 (c)+ TMP_9"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
info.users[msg.sender].balance += _dividends

IRs:
REF_8(mapping(address => bestyearn.User)) -> info.users
REF_9(bestyearn.User) -> REF_8[msg.sender]
REF_10(uint256) -> REF_9.balance
REF_10(-> info) = REF_10 (c)+ _dividends"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(address(this),msg.sender,_dividends)

IRs:
TMP_10 = CONVERT this to address
Emit Transfer(TMP_10.msg.sender._dividends)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Collect(msg.sender,_dividends)

IRs:
Emit Collect(msg.sender._dividends)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
_dividends

IRs:
RETURN _dividends"];
}
